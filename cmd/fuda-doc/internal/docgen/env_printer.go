package docgen

import (
	"fmt"
	"io"
	"strings"

	"github.com/arloliu/fuda/cmd/fuda-doc/internal/docutil"
)

// envEntry holds a flattened env-tagged field.
type envEntry struct {
	EnvVar      string
	Type        string
	Default     string
	YAMLPath    string
	Description string
	Required    string
}

// collectEnvEntries recursively walks a FieldInfo tree and collects all
// fields that have an "env" tag.
func collectEnvEntries(fields []FieldInfo, pathPrefix string) []envEntry {
	var entries []envEntry

	for _, f := range fields {
		if !docutil.IsExported(f.Name) {
			continue
		}

		key := docutil.YAMLKey(&f)
		if key == "-" {
			continue
		}

		path := key
		if pathPrefix != "" {
			path = pathPrefix + "." + key
		}

		if envVar := f.Tags["env"]; envVar != "" {
			entries = append(entries, envEntry{
				EnvVar:      envVar,
				Type:        f.Type,
				Default:     f.Tags["default"],
				YAMLPath:    path,
				Description: f.Description,
				Required:    f.Tags["required"],
			})
		}

		if len(f.Nested) > 0 {
			entries = append(entries, collectEnvEntries(f.Nested, path)...)
		}
	}

	return entries
}

// PrintEnvSummary writes a formatted table of all env-tagged fields across
// all parsed structs.
func PrintEnvSummary(docs []StructDoc, w io.Writer) error {
	var all []envEntry

	for _, d := range docs {
		all = append(all, collectEnvEntries(d.Fields, "")...)
	}

	if len(all) == 0 {
		_, _ = fmt.Fprintln(w, "No env-tagged fields found.")

		return nil
	}

	// Calculate column widths.
	envW, typeW, defW, pathW := len("ENV VAR"), len("TYPE"), len("DEFAULT"), len("YAML PATH")

	for _, e := range all {
		envW = max(envW, len(e.EnvVar))
		typeW = max(typeW, len(e.Type))
		defW = max(defW, len(e.Default))
		pathW = max(pathW, len(e.YAMLPath))
	}

	// Print header.
	hdr := fmt.Sprintf("%-*s  %-*s  %-*s  %-*s  %s",
		envW, "ENV VAR", typeW, "TYPE", defW, "DEFAULT", pathW, "YAML PATH", "DESCRIPTION")
	_, _ = fmt.Fprintln(w, hdr)

	sep := strings.Repeat("─", envW) + "  " +
		strings.Repeat("─", typeW) + "  " +
		strings.Repeat("─", defW) + "  " +
		strings.Repeat("─", pathW) + "  " +
		strings.Repeat("─", 11) //nolint:mnd // "DESCRIPTION" column header width
	_, _ = fmt.Fprintln(w, sep)

	// Print rows.
	for _, e := range all {
		def := e.Default
		if def == "" {
			def = "-"
		}

		desc := e.Description
		if desc == "" {
			desc = "-"
		}

		// Only show the first line of the description (brief).
		desc = docutil.FirstLine(desc)

		row := fmt.Sprintf("%-*s  %-*s  %-*s  %-*s  %s",
			envW, e.EnvVar, typeW, e.Type, defW, def, pathW, e.YAMLPath, desc)
		_, _ = fmt.Fprintln(w, row)
	}

	_, _ = fmt.Fprintf(w, "\nTotal: %d env-tagged fields\n", len(all))

	return nil
}

// PrintEnvFile writes a .env.example-style file with comments showing
// descriptions, types, and YAML paths for each env-tagged field.
func PrintEnvFile(docs []StructDoc, w io.Writer) error {
	var all []envEntry

	for _, d := range docs {
		all = append(all, collectEnvEntries(d.Fields, "")...)
	}

	if len(all) == 0 {
		_, _ = fmt.Fprintln(w, "# No env-tagged fields found.")

		return nil
	}

	_, _ = fmt.Fprintln(w, "# Auto-generated .env.example")
	_, _ = fmt.Fprintln(w, "# Generated by fuda-doc --env-file")
	_, _ = fmt.Fprintln(w)

	for i, e := range all {
		if e.Description != "" {
			// Prefix each line of multiline descriptions with #.
			for _, line := range strings.Split(e.Description, "\n") {
				_, _ = fmt.Fprintf(w, "# %s\n", line)
			}
		}

		_, _ = fmt.Fprintf(w, "# Type: %s | YAML: %s", e.Type, e.YAMLPath)

		if e.Required != "" {
			_, _ = fmt.Fprintf(w, " | Required: %s", e.Required)
		}

		_, _ = fmt.Fprintln(w)

		def := e.Default
		if def == "" {
			_, _ = fmt.Fprintf(w, "# %s=\n", e.EnvVar)
		} else {
			_, _ = fmt.Fprintf(w, "%s=%s\n", e.EnvVar, def)
		}

		if i < len(all)-1 {
			_, _ = fmt.Fprintln(w)
		}
	}

	return nil
}
